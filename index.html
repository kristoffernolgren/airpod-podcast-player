<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirPod Podcast Player</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ§</text></svg>">
    <style>
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            min-height: 100vh;
            color: #33ff33;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            border: 1px solid #33ff33;
            padding: 20px;
        }

        .status {
            border: 1px solid #33ff33;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .status.active {
            background: rgba(51, 255, 51, 0.1);
        }

        .log {
            background: #111;
            border: 1px solid #222;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 1000;
        }

        .start-overlay .prompt {
            text-align: center;
        }

        .start-overlay .prompt-text {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .start-overlay .prompt-hint {
            font-size: 14px;
            opacity: 0.6;
        }

        .start-overlay.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="startOverlay" class="start-overlay">
        <div class="prompt">
            <div class="prompt-text">[ Tap to start ]</div>
            <div class="prompt-hint">Required for audio playback</div>
        </div>
    </div>
    <div class="container">
        <div id="status" class="status">Loading episodes...</div>
        <div class="log" id="log"></div>
    </div>

    <script>
        // Generate a tiny silent WAV file instead of MP3 (better compatibility)
        function generateSilentWav() {
            // Minimal WAV file: 1 second of silence, 22050 Hz, mono, 8-bit
            const sampleRate = 22050;
            const numChannels = 1;
            const bitsPerSample = 8;
            const duration = 1; // 1 second
            const numSamples = sampleRate * duration;
            const dataSize = numSamples * numChannels * (bitsPerSample / 8);

            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // chunk size
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
            view.setUint16(32, numChannels * (bitsPerSample / 8), true);
            view.setUint16(34, bitsPerSample, true);

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Fill with silence (128 for 8-bit audio)
            for (let i = 0; i < numSamples; i++) {
                view.setUint8(44 + i, 128);
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            const blob = new Blob([buffer], { type: 'audio/wav' });
            return URL.createObjectURL(blob);
        }

        const silentAudioUrl = generateSilentWav();
        const backgroundAudio = new Audio(silentAudioUrl);
        backgroundAudio.loop = true;

        // Add error handler for background audio
        backgroundAudio.addEventListener('error', (e) => {
            log(`Background audio error: ${e.target.error?.message || 'Unknown error'}`);
        });

        // Audio element for actual podcast playback
        let podcastAudio = null;
        let allEpisodes = [];
        let currentEpisode = null;
        let isPlaying = false;
        let stopTimer = null;
        let countdownInterval = null;
        let playStartTime = null;

        // Time control constants (in seconds)
        const START_OFFSET_SECONDS = 300;  // Start 5 minutes into episode
        const PLAY_DURATION_SECONDS = 900; // Play for 15 minutes

        // RSS Feed URL
        const RSS_FEED_URL = 'https://audioboom.com/channels/2399216.rss';

        // Logging function
        function log(message) {
            console.log(message);
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.insertBefore(entry, logDiv.firstChild);
        }

        // Update status display
        function updateStatus(message, isActive = false) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            if (isActive) {
                statusDiv.classList.add('active');
            } else {
                statusDiv.classList.remove('active');
            }
        }

        // Format seconds to mm:ss
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Start countdown timer display
        function startCountdown() {
            playStartTime = Date.now();
            if (countdownInterval) clearInterval(countdownInterval);

            countdownInterval = setInterval(() => {
                const elapsed = (Date.now() - playStartTime) / 1000;
                const remaining = Math.max(0, PLAY_DURATION_SECONDS - elapsed);

                if (remaining > 0 && currentEpisode) {
                    updateStatus(`Playing: ${currentEpisode.title} [${formatTime(remaining)}]`, true);
                }
            }, 1000);
        }

        // Stop countdown timer
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            playStartTime = null;
        }

        // Fetch with timeout
        async function fetchWithTimeout(url, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        // Fetch a single RSS page using CORS proxy
        async function fetchRSSPage(feedUrl) {
            const proxies = [
                { name: 'AllOrigins', url: `https://api.allorigins.win/raw?url=${encodeURIComponent(feedUrl)}` },
                { name: 'CORSProxy', url: `https://corsproxy.io/?${encodeURIComponent(feedUrl)}` },
                { name: 'Direct', url: feedUrl }
            ];

            let response;
            let lastError;

            for (const proxy of proxies) {
                try {
                    const startTime = Date.now();
                    log(`Trying ${proxy.name}...`);
                    response = await fetchWithTimeout(proxy.url, 10000);
                    const elapsed = Date.now() - startTime;
                    if (response.ok) {
                        log(`+ ${proxy.name} ok (${elapsed}ms)`);
                        break;
                    } else {
                        log(`- ${proxy.name} failed: ${response.status} (${elapsed}ms)`);
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        log(`- ${proxy.name} timeout`);
                    } else {
                        log(`- ${proxy.name}: ${error.message}`);
                    }
                    lastError = error;
                    continue;
                }
            }

            if (!response || !response.ok) {
                throw lastError || new Error('All proxy attempts failed');
            }

            log('Reading response body...');
            const text = await response.text();
            log(`Response body: ${text.length} chars`);
            return text;
        }

        // Parse episodes from XML document
        function parseEpisodesFromXml(xmlDoc) {
            const episodes = [];
            const items = xmlDoc.querySelectorAll('item');

            items.forEach(item => {
                const title = item.querySelector('title')?.textContent || 'Unknown Title';
                const enclosure = item.querySelector('enclosure');
                const audioUrl = enclosure?.getAttribute('url') || null;

                if (audioUrl) {
                    episodes.push({ title, audioUrl });
                }
            });

            return episodes;
        }

        // Get next page URL from RSS feed (Atom pagination)
        function getNextPageUrl(xmlDoc) {
            // Look for <atom:link rel="next" href="...">
            const atomLinks = xmlDoc.querySelectorAll('link');
            for (const link of atomLinks) {
                if (link.getAttribute('rel') === 'next') {
                    return link.getAttribute('href');
                }
            }
            return null;
        }

        // Fetch RSS feed using CORS proxy (all pages)
        async function fetchRSSFeed() {
            log('Fetching podcast feed...');
            allEpisodes = [];

            try {
                let currentUrl = RSS_FEED_URL;
                let pageCount = 0;

                while (currentUrl) {
                    pageCount++;
                    log(`Page ${pageCount}...`);

                    const xmlText = await fetchRSSPage(currentUrl);
                    log('Parsing XML...');
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    log('Extracting episodes...');
                    const pageEpisodes = parseEpisodesFromXml(xmlDoc);
                    if (pageEpisodes.length === 0 && pageCount === 1) {
                        throw new Error('No episodes found in RSS feed');
                    }

                    allEpisodes.push(...pageEpisodes);
                    log(`+ ${pageEpisodes.length} episodes`);

                    // Check for next page
                    log('Checking for next page...');
                    currentUrl = getNextPageUrl(xmlDoc);
                    log(`Next page: ${currentUrl ? currentUrl : 'none'}`);
                }

                log(`Total: ${allEpisodes.length} episodes`);
                return allEpisodes;

            } catch (error) {
                log(`Error: ${error.message}`);
                updateStatus('Error loading feed', false);
                throw error;
            }
        }

        // Get a random episode from all loaded episodes
        function getRandomEpisode() {
            if (allEpisodes.length === 0) return null;
            return allEpisodes[Math.floor(Math.random() * allEpisodes.length)];
        }

        // Setup Media Session API
        function setupMediaSession() {
            if ('mediaSession' in navigator) {
                log('Setting up Media Session...');

                // Set metadata
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: "AirPod Podcast Controller",
                    artist: "Ready to play latest episode",
                    album: "Click AirPod to start"
                });

                navigator.mediaSession.playbackState = "playing";

                // Intercept PAUSE command (AirPod single click)
                navigator.mediaSession.setActionHandler('pause', () => {
                    log('AirPod clicked!');
                    handleAirPodClick();

                    // Keep background audio playing
                    backgroundAudio.play();
                    navigator.mediaSession.playbackState = "playing";
                });

                // Intercept PLAY command
                navigator.mediaSession.setActionHandler('play', () => {
                    log('Play command');
                    backgroundAudio.play();
                    navigator.mediaSession.playbackState = "playing";
                });

                // Optional: Handle next/previous track (double/triple click)
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    log('Skip +30s');
                    if (podcastAudio && isPlaying) {
                        podcastAudio.currentTime += 30;
                    }
                });

                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    log('Skip -30s');
                    if (podcastAudio && isPlaying) {
                        podcastAudio.currentTime -= 30;
                    }
                });

                log('Media Session configured');
            } else {
                log('Media Session API not supported');
            }
        }

        // Configure audio session for iOS
        function setupAudioSession() {
            if ('audioSession' in navigator) {
                navigator.audioSession.type = 'playback';
                log('Audio session: playback');
            }
        }

        // Handle AirPod click - pause if playing, otherwise start new random episode
        function handleAirPodClick() {
            // Store event in localStorage for persistence
            const clickCount = parseInt(localStorage.getItem('airpod_clicks') || '0', 10) + 1;
            localStorage.setItem('airpod_clicks', clickCount.toString());
            localStorage.setItem('last_click_timestamp', Date.now().toString());

            if (allEpisodes.length === 0) {
                log('No episodes loaded');
                return;
            }

            // If currently playing, just pause
            if (podcastAudio && !podcastAudio.paused) {
                log('Pausing...');
                podcastAudio.pause();
                if (stopTimer) {
                    clearTimeout(stopTimer);
                    stopTimer = null;
                }
                updateStatus('Paused - click for new episode', false);
                return;
            }

            // Stop any existing paused audio
            if (podcastAudio) {
                podcastAudio.src = '';
                podcastAudio = null;
            }
            if (stopTimer) {
                clearTimeout(stopTimer);
                stopTimer = null;
            }
            stopCountdown();

            // Pick a random episode
            currentEpisode = getRandomEpisode();
            log(`Playing: ${currentEpisode.title}`);

            podcastAudio = new Audio(currentEpisode.audioUrl);

            podcastAudio.addEventListener('loadstart', () => {
                log('Loading...');
            });

            podcastAudio.addEventListener('loadedmetadata', () => {
                const duration = Math.round(podcastAudio.duration / 60);
                log(`Duration: ${duration}min`);

                // Seek to 5 minutes in (or start, if episode is shorter)
                if (podcastAudio.duration > START_OFFSET_SECONDS) {
                    podcastAudio.currentTime = START_OFFSET_SECONDS;
                    log(`Seek: ${START_OFFSET_SECONDS / 60}min`);
                }
            });

            podcastAudio.addEventListener('canplay', () => {
                log('Ready');
            });

            podcastAudio.addEventListener('playing', () => {
                log(`Playing from ${Math.round(podcastAudio.currentTime / 60)}min`);
                isPlaying = true;
                startCountdown();

                // Update media session metadata
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: currentEpisode.title,
                        artist: "Random Episode",
                        album: "AirPod Controller"
                    });
                }

                // Set 15-minute auto-stop timer
                if (stopTimer) clearTimeout(stopTimer);
                stopTimer = setTimeout(() => {
                    log(`Auto-stop (${PLAY_DURATION_SECONDS / 60}min limit)`);
                    stopCountdown();
                    if (podcastAudio) {
                        podcastAudio.pause();
                        podcastAudio.src = '';
                        podcastAudio = null;
                    }
                    isPlaying = false;
                    updateStatus('Stopped - click for new episode', false);
                }, PLAY_DURATION_SECONDS * 1000);
            });

            podcastAudio.addEventListener('pause', () => {
                // Only log if not auto-stopped
                if (podcastAudio && podcastAudio.src) {
                    log('Paused');
                    isPlaying = false;
                    stopCountdown();
                }
            });

            podcastAudio.addEventListener('ended', () => {
                log('Ended');
                isPlaying = false;
                stopCountdown();
                if (stopTimer) {
                    clearTimeout(stopTimer);
                    stopTimer = null;
                }
                updateStatus('Finished - click for new episode', false);
            });

            podcastAudio.addEventListener('error', (e) => {
                const errorDetails = e.target.error;
                let errorMsg = 'Unknown error';
                if (errorDetails) {
                    switch(errorDetails.code) {
                        case 1: errorMsg = 'MEDIA_ERR_ABORTED'; break;
                        case 2: errorMsg = 'MEDIA_ERR_NETWORK'; break;
                        case 3: errorMsg = 'MEDIA_ERR_DECODE'; break;
                        case 4: errorMsg = 'MEDIA_ERR_SRC_NOT_SUPPORTED'; break;
                    }
                }
                log(`Error: ${errorMsg}`);
                updateStatus(`Error: ${errorMsg}`, false);
            });

            podcastAudio.play().catch(err => {
                log(`Error: ${err.message}`);
                updateStatus(`Error: ${err.message}`, false);
            });
        }

        // Auto-initialize on page load
        async function init() {
            log('Initializing...');

            try {
                // Step 1: Start silent audio loop
                log('Starting background audio...');
                updateStatus('Starting...', false);

                try {
                    await backgroundAudio.play();
                    log('+ Background audio ok');
                } catch (audioError) {
                    log(`Background audio: ${audioError.message}`);
                    throw new Error(`Background audio: ${audioError.message}`);
                }

                // Step 2: Setup audio session
                log('Configuring audio session...');
                setupAudioSession();

                // Step 3: Fetch all episodes
                updateStatus('Loading episodes...', false);

                try {
                    await fetchRSSFeed();
                    log(`+ ${allEpisodes.length} episodes loaded`);
                } catch (rssError) {
                    throw new Error(`Feed: ${rssError.message}`);
                }

                // Step 4: Setup media session
                log('Setting up AirPod controls...');
                setupMediaSession();

                updateStatus('Ready - lock phone and click AirPod', true);
                log('Ready');

            } catch (error) {
                log(`Init error: ${error.message}`);
                updateStatus(`Error: ${error.message}`, false);
            }
        }

        // Start when user taps the overlay (required for autoplay policy)
        document.getElementById('startOverlay').addEventListener('click', function() {
            this.classList.add('hidden');
            init();
        });
    </script>
</body>
</html>
