<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirPod Podcast Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        button {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin-bottom: 15px;
        }

        #start-session-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        #start-session-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        #start-session-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status.active {
            background: rgba(76, 175, 80, 0.3);
        }

        .episode-info {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .episode-info h3 {
            margin-top: 0;
        }

        .log {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ§ AirPod Podcast Player</h1>
        <p class="subtitle">Control with your AirPods while iPhone is locked</p>

        <div class="instructions">
            <strong>How to use:</strong>
            <ol>
                <li>Click "Enable AirPod Control" below</li>
                <li>Lock your iPhone</li>
                <li>Click your AirPod play/pause button to start the latest episode</li>
            </ol>
        </div>

        <div id="status" class="status">
            Not active - Click button below to enable
        </div>

        <button id="start-session-btn">Enable AirPod Control</button>

        <div id="episode-info" class="episode-info" style="display: none;">
            <h3>Latest Episode:</h3>
            <div id="episode-title">Loading...</div>
        </div>

        <div class="log" id="log"></div>
    </div>

    <script>
        // Generate a tiny silent WAV file instead of MP3 (better compatibility)
        function generateSilentWav() {
            // Minimal WAV file: 1 second of silence, 22050 Hz, mono, 8-bit
            const sampleRate = 22050;
            const numChannels = 1;
            const bitsPerSample = 8;
            const duration = 1; // 1 second
            const numSamples = sampleRate * duration;
            const dataSize = numSamples * numChannels * (bitsPerSample / 8);

            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // chunk size
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
            view.setUint16(32, numChannels * (bitsPerSample / 8), true);
            view.setUint16(34, bitsPerSample, true);

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Fill with silence (128 for 8-bit audio)
            for (let i = 0; i < numSamples; i++) {
                view.setUint8(44 + i, 128);
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            const blob = new Blob([buffer], { type: 'audio/wav' });
            return URL.createObjectURL(blob);
        }

        const silentAudioUrl = generateSilentWav();
        const backgroundAudio = new Audio(silentAudioUrl);
        backgroundAudio.loop = true;

        // Add error handler for background audio
        backgroundAudio.addEventListener('error', (e) => {
            log(`Background audio error: ${e.target.error?.message || 'Unknown error'}`);
        });

        // Audio element for actual podcast playback
        let podcastAudio = null;
        let allEpisodes = [];
        let currentEpisode = null;
        let isPlaying = false;
        let stopTimer = null;

        // Time control constants (in seconds)
        const START_OFFSET_SECONDS = 300;  // Start 5 minutes into episode
        const PLAY_DURATION_SECONDS = 900; // Play for 15 minutes

        // RSS Feed URL
        const RSS_FEED_URL = 'https://audioboom.com/channels/2399216.rss';

        // Logging function
        function log(message) {
            console.log(message);
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.insertBefore(entry, logDiv.firstChild);
        }

        // Update status display
        function updateStatus(message, isActive = false) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            if (isActive) {
                statusDiv.classList.add('active');
            } else {
                statusDiv.classList.remove('active');
            }
        }

        // Fetch with timeout
        async function fetchWithTimeout(url, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        // Fetch a single RSS page using CORS proxy
        async function fetchRSSPage(feedUrl) {
            const proxies = [
                { name: 'AllOrigins', url: `https://api.allorigins.win/raw?url=${encodeURIComponent(feedUrl)}` },
                { name: 'CORSProxy', url: `https://corsproxy.io/?${encodeURIComponent(feedUrl)}` },
                { name: 'Direct', url: feedUrl }
            ];

            let response;
            let lastError;

            for (const proxy of proxies) {
                try {
                    log(`Trying ${proxy.name}...`);
                    response = await fetchWithTimeout(proxy.url, 10000);
                    if (response.ok) {
                        log(`âœ“ Success with ${proxy.name}`);
                        break;
                    } else {
                        log(`âœ— ${proxy.name} failed with status ${response.status}`);
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        log(`âœ— ${proxy.name} timed out after 10s`);
                    } else {
                        log(`âœ— ${proxy.name} error: ${error.message}`);
                    }
                    lastError = error;
                    continue;
                }
            }

            if (!response || !response.ok) {
                throw lastError || new Error('All proxy attempts failed');
            }

            return response.text();
        }

        // Parse episodes from XML document
        function parseEpisodesFromXml(xmlDoc) {
            const episodes = [];
            const items = xmlDoc.querySelectorAll('item');

            items.forEach(item => {
                const title = item.querySelector('title')?.textContent || 'Unknown Title';
                const enclosure = item.querySelector('enclosure');
                const audioUrl = enclosure?.getAttribute('url') || null;

                if (audioUrl) {
                    episodes.push({ title, audioUrl });
                }
            });

            return episodes;
        }

        // Get next page URL from RSS feed (Atom pagination)
        function getNextPageUrl(xmlDoc) {
            // Look for <atom:link rel="next" href="...">
            const atomLinks = xmlDoc.querySelectorAll('link');
            for (const link of atomLinks) {
                if (link.getAttribute('rel') === 'next') {
                    return link.getAttribute('href');
                }
            }
            return null;
        }

        // Fetch RSS feed using CORS proxy (all pages)
        async function fetchRSSFeed() {
            log('Fetching all podcast episodes...');
            allEpisodes = [];

            try {
                let currentUrl = RSS_FEED_URL;
                let pageCount = 0;

                while (currentUrl) {
                    pageCount++;
                    log(`Fetching page ${pageCount}...`);

                    const xmlText = await fetchRSSPage(currentUrl);
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    const pageEpisodes = parseEpisodesFromXml(xmlDoc);
                    if (pageEpisodes.length === 0 && pageCount === 1) {
                        throw new Error('No episodes found in RSS feed');
                    }

                    allEpisodes.push(...pageEpisodes);
                    log(`Found ${pageEpisodes.length} episodes on page ${pageCount}`);

                    // Check for next page
                    currentUrl = getNextPageUrl(xmlDoc);
                }

                log(`Total episodes loaded: ${allEpisodes.length}`);

                // Display episode count
                document.getElementById('episode-info').style.display = 'block';
                document.getElementById('episode-title').textContent = `${allEpisodes.length} episodes available`;

                return allEpisodes;

            } catch (error) {
                log(`Error fetching RSS feed: ${error.message}`);
                updateStatus('Error loading podcast feed', false);
                throw error;
            }
        }

        // Get a random episode from all loaded episodes
        function getRandomEpisode() {
            if (allEpisodes.length === 0) return null;
            return allEpisodes[Math.floor(Math.random() * allEpisodes.length)];
        }

        // Setup Media Session API
        function setupMediaSession() {
            if ('mediaSession' in navigator) {
                log('Setting up Media Session API...');

                // Set metadata
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: "AirPod Podcast Controller",
                    artist: "Ready to play latest episode",
                    album: "Click AirPod to start"
                });

                navigator.mediaSession.playbackState = "playing";

                // Intercept PAUSE command (AirPod single click)
                navigator.mediaSession.setActionHandler('pause', () => {
                    log('AirPod clicked! Starting latest podcast episode...');
                    handleAirPodClick();

                    // Keep background audio playing
                    backgroundAudio.play();
                    navigator.mediaSession.playbackState = "playing";
                });

                // Intercept PLAY command
                navigator.mediaSession.setActionHandler('play', () => {
                    log('Play command received');
                    backgroundAudio.play();
                    navigator.mediaSession.playbackState = "playing";
                });

                // Optional: Handle next/previous track (double/triple click)
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    log('Next track (double click)');
                    if (podcastAudio && isPlaying) {
                        podcastAudio.currentTime += 30; // Skip forward 30s
                    }
                });

                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    log('Previous track (triple click)');
                    if (podcastAudio && isPlaying) {
                        podcastAudio.currentTime -= 30; // Skip back 30s
                    }
                });

                log('Media Session API configured');
            } else {
                log('Media Session API not supported');
            }
        }

        // Configure audio session for iOS
        function setupAudioSession() {
            if ('audioSession' in navigator) {
                navigator.audioSession.type = 'playback';
                log('Audio session type set to playback');
            }
        }

        // Handle AirPod click - toggle podcast playback
        function handleAirPodClick() {
            // Store event in localStorage for persistence
            const clickCount = parseInt(localStorage.getItem('airpod_clicks') || '0', 10) + 1;
            localStorage.setItem('airpod_clicks', clickCount.toString());
            localStorage.setItem('last_click_timestamp', Date.now().toString());

            if (!latestEpisode) {
                log('No episode loaded yet');
                return;
            }

            if (!podcastAudio) {
                // First click - create and start playing podcast
                log(`Creating podcast audio player for: ${latestEpisode.audioUrl}`);
                podcastAudio = new Audio(latestEpisode.audioUrl);

                podcastAudio.addEventListener('loadstart', () => {
                    log('Podcast: Loading started...');
                });

                podcastAudio.addEventListener('loadedmetadata', () => {
                    log(`Podcast: Metadata loaded (duration: ${Math.round(podcastAudio.duration / 60)}min)`);
                });

                podcastAudio.addEventListener('canplay', () => {
                    log('Podcast: Ready to play');
                });

                podcastAudio.addEventListener('playing', () => {
                    log('Podcast is now playing');
                    isPlaying = true;
                    updateStatus(`Playing: ${latestEpisode.title}`, true);

                    // Update media session metadata
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: latestEpisode.title,
                            artist: "Podcast Episode",
                            album: "AirPod Controller"
                        });
                    }
                });

                podcastAudio.addEventListener('pause', () => {
                    log('Podcast paused');
                    isPlaying = false;
                    updateStatus('Paused - Click AirPod to resume', false);
                });

                podcastAudio.addEventListener('ended', () => {
                    log('Podcast ended');
                    isPlaying = false;
                    updateStatus('Episode finished', false);
                });

                podcastAudio.addEventListener('error', (e) => {
                    const errorDetails = e.target.error;
                    let errorMsg = 'Unknown error';
                    if (errorDetails) {
                        switch(errorDetails.code) {
                            case 1: errorMsg = 'MEDIA_ERR_ABORTED'; break;
                            case 2: errorMsg = 'MEDIA_ERR_NETWORK'; break;
                            case 3: errorMsg = 'MEDIA_ERR_DECODE'; break;
                            case 4: errorMsg = 'MEDIA_ERR_SRC_NOT_SUPPORTED'; break;
                        }
                    }
                    log(`Podcast playback error: ${errorMsg}`);
                    updateStatus(`Playback error: ${errorMsg}`, false);
                });

                podcastAudio.play().catch(err => {
                    log(`Error starting podcast: ${err.message}`);
                    updateStatus(`Error: ${err.message}`, false);
                });

            } else {
                // Toggle play/pause
                if (podcastAudio.paused) {
                    log('Resuming podcast...');
                    podcastAudio.play();
                } else {
                    log('Pausing podcast...');
                    podcastAudio.pause();
                }
            }
        }

        // Start session button handler
        document.getElementById('start-session-btn').addEventListener('click', async () => {
            const button = document.getElementById('start-session-btn');
            button.disabled = true;
            button.textContent = 'Initializing...';

            try {
                // Step 1: Start silent audio loop
                log('Step 1: Starting background audio...');
                updateStatus('Starting background audio...', false);

                try {
                    await backgroundAudio.play();
                    log('âœ“ Background audio loop started successfully');
                } catch (audioError) {
                    log(`Background audio failed: ${audioError.message}`);
                    throw new Error(`Background audio failed: ${audioError.message}`);
                }

                // Step 2: Setup audio session
                log('Step 2: Configuring audio session...');
                updateStatus('Configuring audio session...', false);
                setupAudioSession();
                log('âœ“ Audio session configured');

                // Step 3: Fetch latest episode
                log('Step 3: Fetching latest podcast episode...');
                updateStatus('Loading latest episode...', false);

                try {
                    await fetchRSSFeed();
                    log('âœ“ Episode loaded successfully');
                } catch (rssError) {
                    log(`RSS fetch failed: ${rssError.message}`);
                    throw new Error(`Failed to load podcast feed: ${rssError.message}`);
                }

                // Step 4: Setup media session
                log('Step 4: Setting up AirPod controls...');
                updateStatus('Enabling AirPod controls...', false);
                setupMediaSession();
                log('âœ“ AirPod controls enabled');

                updateStatus('Active - Lock your phone and click your AirPod!', true);
                button.textContent = 'Active - AirPod Control Enabled';

                log('âœ“ All systems ready! Lock your iPhone and click your AirPod.');

            } catch (error) {
                log(`âœ— Initialization error: ${error.message}`);
                button.disabled = false;
                button.textContent = 'Retry Enable AirPod Control';
                updateStatus(`Error: ${error.message}`, false);
            }
        });

        // Log initial load
        log('Page loaded. Click "Enable AirPod Control" to begin.');
    </script>
</body>
</html>
